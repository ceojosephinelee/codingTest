import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
 
public class Main {
    static int[] parent;
	public static void main(String[] args) throws IOException {
        
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 
 		String str = br.readLine();
		StringTokenizer st = new StringTokenizer(str," ");
		int N = Integer.parseInt(st.nextToken());
		int M = Integer.parseInt(st.nextToken());
        parent = new int[N+1];//대표 노드
        for(int i=0;i<=N;i++){ //범위 주의!!!
            parent[i]=i; //대표 노드를 자기 자신으로 초기화하기
        }
        for(int i =0;i<M;i++){
            st = new StringTokenizer(br.readLine()," ");
		    int ZeroOne = Integer.parseInt(st.nextToken());
		    int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());  
            if(ZeroOne==0){
                union(a,b);
                
            }else{
                if(find(a)==find(b)){
                    System.out.println("YES");
                }else{
                    System.out.println("NO");
                }
                
            }
        }
    }
    public static void union(int a, int b){
        if(find(a)!=find(b)){
            parent[find(b)]=find(a);//대표 노드를 a로 바꿔줌-->합집합 효과//주의!!!!!
        }      
    }
    public static int find(int a){ //a가 포함된 집합의 대표 노드 찾아줘
        if(a==parent[a]){ //a가 포함된 집합의 루트가 a이면 a return 또는 이럴 때까지 재귀연산 해줘라는 뜻
            return a;
        }else{ //a가 포함된 집합의 루트가 a가 아니면 찾아야 함-->루트 노드 포함 배열에서 재귀 연산으로
            return parent[a]=find(parent[a]);
        }     
    }
}
