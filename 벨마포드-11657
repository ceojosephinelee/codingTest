import java.io.*;
import java.util.*;

public class Main {
    static long[] distance;// 타입 주의!(항상 범위 체크)
    static Edge[] edges; //간선 배열
    static int N,M;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine()," ");
        N = Integer.parseInt(st.nextToken()); //노드
        M = Integer.parseInt(st.nextToken()); //에지
        edges = new Edge[M+1];
        distance = new long[N+1];
        for (int i = 1; i <= N; i++) {
            distance[i] = Integer.MAX_VALUE;
        }
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine()," ");
            int s = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            edges[i]=new Edge(s,e,v);
        }
        //벨만포드 알고리즘 시작
        distance[1]=0; // 문제에서 1번에서 출발한다고 주어짐.
        for (int i = 2; i <= N; i++) { //N-1만큼만 반복하기(노드-1)
            for(int j=0;j<M;j++){
                Edge e=edges[j];
                if(distance[e.start]!=Integer.MAX_VALUE && distance[e.end]>distance[e.start]+e.value){
                    distance[e.end]=distance[e.start]+e.value;
                }
            }

        }
        boolean mCycle = false; //음수 사이클이 존재하면 true
        for(int i=0;i<M;i++){
            Edge e=edges[i];
            if(distance[e.start] != Integer.MAX_VALUE && distance[e.end]>distance[e.start]+e.value){
                mCycle = true; //갱신되면 음수사이클 존재
            }
        }
        if(mCycle){
            System.out.println("-1");
        }else{
            for(int i=2;i<=N;i++){
                if(distance[i]!=Integer.MAX_VALUE){
                    System.out.println(distance[i]);
                }else{
                    System.out.println("-1");
                }

            }
        }
    }
    static class Edge{
        int start;
        int end;
        int value;
        Edge(int start, int end, int value) {
            this.start = start;
            this.end = end;
            this.value = value;
        }
    }
}
