import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
 
public class Main {
    public static int[] A, tmp;
    public static long result;
	public static void main(String[] args) throws IOException {
        
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));


 		int N = Integer.parseInt(br.readLine());
        A= new int[N+1];
        tmp = new int[N+1];
        for(int i =1;i<=N;i++){
            A[i]=Integer.parseInt(br.readLine());
        }
        mergeSort(1,N);
        for(int i=1;i<=N;i++){
            System.out.println(A[i]);
        }
    }
    public static void mergeSort(int s, int e){
        //쪼개기
        if(e-s<1){
            return;
        }
        int m = s+(e-s)/2;
        //재귀 호출
        mergeSort(s,m);
        mergeSort(m+1,e);
        //정렬할 배열 tmp
        for(int i=s;i<=e;i++){
            tmp[i]=A[i];
        }
        int k =s;// 몇번째 원소까지 채워졌나 세는 것....for문 돌려도 됨 but 더 복잡
        int index1 =s;
        int index2 = m+1;
        //합병하는 과정
        while(index1<=m && index2<=e){
            if(tmp[index1]>tmp[index2]){
                A[k]=tmp[index2];
                k++;
                index2++;
            }else{
                A[k]=tmp[index1];
                k++;
                index1++;
                
            }
            
        }  
        // 한 쪽 그룹 모두 선택된 경우 나머지 그냥 그대로 출력
        while(index1<=m){
            A[k]=tmp[index1];
            k++;
            index1++;            
        }
        while(index2<=e){
            A[k]=tmp[index2];
            k++;
            index2++;            
        }
        
    }
}
