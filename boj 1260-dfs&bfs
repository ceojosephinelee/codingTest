import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.Collections;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;
 
public class Main {
    static int N,M,V;
    static ArrayList<Integer>[] A;
    static boolean[] visited;
       
	public static void main(String[] args) throws IOException {
        
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 
 		String str = br.readLine();
		StringTokenizer st = new StringTokenizer(str," ");
		N = Integer.parseInt(st.nextToken()); //노드의 갯수
		M = Integer.parseInt(st.nextToken()); //간선의 갯수
        V = Integer.parseInt(st.nextToken()); //시작 노드
        A = new ArrayList[N+1]; //인접 리스트를 담은 배열 선언(길이가 가변:리스트, 고정: 배열).배열 길이: 노드 개수

        for(int i =1;i<=N;i++){ //인덱스 숫자가 의미 있으므로 주의!
            A[i] = new ArrayList<Integer>();
        }
        
        for(int i =1;i<=M;i++){ //간선 개수만큼 반복. 인덱스 숫자 의미 없음.
            st = new StringTokenizer(br.readLine()," ");
            int s = Integer.parseInt(st.nextToken());
		    int e = Integer.parseInt(st.nextToken());
            A[s].add(e); //양방향 그래프: 시점 종점에 다시 각각 원소 추가(list니까 add)
            A[e].add(s);   
        }
        //번호가 작은 것부터 방문: 인접 리스트의 값들 정렬!
        for(int i =1;i<=N;i++){
            Collections.sort(A[i]); //Arrays.sort 쓰면 안됨. list니까
        }
        //방문 배열 초기화
        visited = new boolean[N+1];//방문 배열 길이: 노드 개수
        //DFS. 노드 방문 순서대로 출력
        DFS(V);//시작 노드 줘야함.
        //방문 배열 초기화
        System.out.println();
        visited = new boolean[N+1];
        //BFS .노드 방문 순서대로 출력
        BFS(V);
    }
    public static void DFS(int node){//재귀. 스택 자료구조. 인접리스트에서 노드(원소) 빼오는 순서. 방문 순서.
        System.out.print(node+" ");
        visited[node]=true;
        for(int i: A[node]){//node의 인접리스트의 원소 중 방문 안한 원소가 있으면 재귀. 이게 dfs 방식
            if(!visited[i]){//방문배열.방문 안했으면 방문하고 출력.
                DFS(i);
            }
        }
        
    }
    public static void BFS(int node){//큐 자료구조
        Queue<Integer> queue = new LinkedList<Integer>(); //큐 선언.
        queue.add(node);//큐에 원소 집어넣기
        visited[node]= true;
        
        while(!queue.isEmpty()){ //큐의 값을 모두 빼낼때까지
            int now_Node= queue.poll();
            System.out.print(now_Node+" ");
            for(int i : A[now_Node]){
                if(!visited[i]){
                    visited[i]=true;
                    queue.add(i);
                }
            }
        }
    }
}
