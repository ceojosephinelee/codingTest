//완전 탐색이 아니라 백트래킹. 숫자 순서는 고정! 연산자만 dfs해주면 됨!!
//주의 사항(변수명과 배열 명도 동일하지 않게!! 주의!!)
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
 
public class Main {
    public static int[] number, operator;
    public static int N, min, max;
    
	public static void main(String[] args) throws IOException {
        
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		N = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine()," ");
        number = new int[N];
        for(int i =0;i<N;i++){
            number[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine()," ");
        operator = new int[4];
        for(int i =0;i<4;i++){
            operator[i]=Integer.parseInt(st.nextToken()); //+, - ,x, /
        }
        max=Integer.MIN_VALUE; //0 이런거 하면 안됨. 음수도 되니까
        min=Integer.MAX_VALUE;
        calculator(number[0], 1);
        
        System.out.println(max);
        System.out.println(min);
    }
    public static void calculator(int num, int numIndex){ //num: 현재 계산하려는 숫자. numIndex(다음 숫자의 인덱스)
        if(numIndex==N){
            max = Math.max(num, max);
            min = Math.min(num, min);
            return;
        }
        for(int i=0;i<4;i++){
            if(operator[i]>0){
                operator[i]--; //연산자 사용 후 사용 처리
                switch(i){
                    case 0:
                        calculator(num+number[numIndex], numIndex+1);
                        break;
                    case 1:
                        calculator(num-number[numIndex], numIndex+1);
                        break;
                    case 2:
                        calculator(num*number[numIndex], numIndex+1);
                        break;
                    case 3:
                        calculator(num/number[numIndex], numIndex+1);
                        break;
                }
                operator[i]++; //한 차례 dfs 끝나면 원상 복구
                
            }
            
            
        }
    }
}
